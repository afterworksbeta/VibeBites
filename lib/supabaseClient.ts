
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = 'https://gpfnmupklynwofczxffx.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdwZm5tdXBrbHlud29mY3p4ZmZ4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUzMzc5NDUsImV4cCI6MjA4MDkxMzk0NX0.9wVZ9gLL3_YLgbuPXkIa1pcpZwS2aJiZLlPRb9MKyCE';

export const supabase = createClient(supabaseUrl, supabaseKey);

/*
  === REQUIRED DATABASE SCHEMA ===
  Run this SQL in your Supabase SQL Editor to make the app work:

  -- 1. Profiles Table
  create table public.profiles (
    id uuid references auth.users not null primary key,
    username text,
    avatar_id text default 'cool_kid_01', -- Changed from avatar_seed
    color text default '#b6e3f4',        -- Changed from bg_color
    updated_at timestamp with time zone default timezone('utc'::text, now())
  );
  -- Enable RLS
  alter table public.profiles enable row level security;
  create policy "Public profiles are viewable by everyone." on public.profiles for select using (true);
  create policy "Users can insert their own profile." on public.profiles for insert with check (auth.uid() = id);
  create policy "Users can update own profile." on public.profiles for update using (auth.uid() = id);

  -- 2. Friendships Table (Simplified)
  create table public.friendships (
    id bigint generated by default as identity primary key,
    user_id uuid references public.profiles(id),
    friend_id uuid references public.profiles(id),
    status text default 'ACCEPTED',
    created_at timestamp with time zone default timezone('utc'::text, now())
  );
  alter table public.friendships enable row level security;
  create policy "Users can see their friends" on public.friendships for select using (auth.uid() = user_id OR auth.uid() = friend_id);
  create policy "Users can add friends" on public.friendships for insert with check (auth.uid() = user_id);
  
  -- [FIXED] ADD THIS POLICY TO ENABLE DELETING FRIENDS:
  create policy "Users can delete their friends" on public.friendships for delete using (auth.uid() = user_id OR auth.uid() = friend_id);

  -- 3. Messages Table
  create table public.messages (
    id bigint generated by default as identity primary key,
    sender_id uuid references public.profiles(id),
    receiver_id uuid references public.profiles(id),
    text text,
    emojis jsonb, -- Stores array of emojis
    type text, -- 'INCOMING_UNSOLVED', 'INCOMING_SOLVED', 'OUTGOING' logic handled by app usually, but store raw type or determine by sender
    status text default 'SENT',
    created_at timestamp with time zone default timezone('utc'::text, now())
  );
  alter table public.messages enable row level security;
  create policy "Users can see their messages" on public.messages for select using (auth.uid() = sender_id OR auth.uid() = receiver_id);
  create policy "Users can send messages" on public.messages for insert with check (auth.uid() = sender_id);
  create policy "Users can delete their messages" on public.messages for delete using (auth.uid() = sender_id OR auth.uid() = receiver_id);

  -- 4. Trigger to create profile on signup
  create or replace function public.handle_new_user() 
  returns trigger as $$
  begin
    insert into public.profiles (id, username, avatar_id, color)
    values (
        new.id, 
        new.raw_user_meta_data->>'username', 
        'player_' || floor(random() * 1000)::text,
        '#b6e3f4'
    );
    return new;
  end;
  $$ language plpgsql security definer;

  create trigger on_auth_user_created
    after insert on auth.users
    for each row execute procedure public.handle_new_user();
*/
